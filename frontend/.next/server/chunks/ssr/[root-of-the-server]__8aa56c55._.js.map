{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/lord-charles/Code/work/gap_analysis/frontend/lib/api.ts"],"sourcesContent":["import axios from 'axios';\n\n// Create axios instance with base configuration\nconst api = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000',\n  withCredentials: true, // Important for cookies\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor to add auth token\napi.interceptors.request.use(\n  (config) => {\n    // Get token from localStorage if available\n    if (typeof window !== 'undefined') {\n      const token = localStorage.getItem('accessToken');\n      if (token) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n    }\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor to handle token refresh\napi.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n\n    if (error.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      try {\n        // Try to refresh the token\n        const refreshToken = localStorage.getItem('refreshToken');\n        if (refreshToken) {\n          const response = await axios.post(\n            `${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000'}/auth/refresh`,\n            { refreshToken },\n            { withCredentials: true }\n          );\n\n          const { accessToken } = response.data;\n          localStorage.setItem('accessToken', accessToken);\n\n          // Retry the original request with new token\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n          return api(originalRequest);\n        }\n      } catch {\n        // Refresh failed, redirect to login\n        if (typeof window !== 'undefined') {\n          localStorage.removeItem('accessToken');\n          localStorage.removeItem('refreshToken');\n          window.location.href = '/auth/login';\n        }\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\nexport default api;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,gDAAgD;AAChD,MAAM,MAAM,4JAAK,CAAC,MAAM,CAAC;IACvB,SAAS,QAAQ,GAAG,CAAC,mBAAmB,IAAI;IAC5C,iBAAiB;IACjB,SAAS;QACP,gBAAgB;IAClB;AACF;AAEA,wCAAwC;AACxC,IAAI,YAAY,CAAC,OAAO,CAAC,GAAG,CAC1B,CAAC;IACC,2CAA2C;IAC3C;;IAMA,OAAO;AACT,GACA,CAAC;IACC,OAAO,QAAQ,MAAM,CAAC;AACxB;AAGF,+CAA+C;AAC/C,IAAI,YAAY,CAAC,QAAQ,CAAC,GAAG,CAC3B,CAAC,WAAa,UACd,OAAO;IACL,MAAM,kBAAkB,MAAM,MAAM;IAEpC,IAAI,MAAM,QAAQ,EAAE,WAAW,OAAO,CAAC,gBAAgB,MAAM,EAAE;QAC7D,gBAAgB,MAAM,GAAG;QAEzB,IAAI;YACF,2BAA2B;YAC3B,MAAM,eAAe,aAAa,OAAO,CAAC;YAC1C,IAAI,cAAc;gBAChB,MAAM,WAAW,MAAM,4JAAK,CAAC,IAAI,CAC/B,GAAG,QAAQ,GAAG,CAAC,mBAAmB,IAAI,wBAAwB,aAAa,CAAC,EAC5E;oBAAE;gBAAa,GACf;oBAAE,iBAAiB;gBAAK;gBAG1B,MAAM,EAAE,WAAW,EAAE,GAAG,SAAS,IAAI;gBACrC,aAAa,OAAO,CAAC,eAAe;gBAEpC,4CAA4C;gBAC5C,gBAAgB,OAAO,CAAC,aAAa,GAAG,CAAC,OAAO,EAAE,aAAa;gBAC/D,OAAO,IAAI;YACb;QACF,EAAE,OAAM;YACN,oCAAoC;YACpC;;QAKF;IACF;IAEA,OAAO,QAAQ,MAAM,CAAC;AACxB;uCAGa","debugId":null}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["file:///Users/lord-charles/Code/work/gap_analysis/frontend/lib/auth.ts"],"sourcesContent":["import api from './api';\n\nexport interface LoginCredentials {\n  email: string;\n  password: string;\n  organizationId?: number;\n  domain?: string;\n}\n\nexport interface Organization {\n  id: number;\n  name: string;\n  domain: string;\n  subdomain?: string;\n  isActive: boolean;\n}\n\nexport interface RegisterData {\n  firstName: string;\n  lastName: string;\n  email: string;\n  password: string;\n  role?: string;\n  branchId?: number;\n}\n\nexport interface User {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n  role: string;\n  isActive: boolean;\n  organizationId: number;\n  organization?: {\n    id: number;\n    name: string;\n    domain: string;\n    subdomain?: string;\n  };\n  branchId?: number;\n  branch?: {\n    id: number;\n    name: string;\n    region: string;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface AuthResponse {\n  user: User;\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport const authService = {\n  // Login user (standard login)\n  async login(credentials: LoginCredentials): Promise<AuthResponse> {\n    const response = await api.post('/auth/login', credentials);\n    \n    // Get tokens from response data (backend now returns them)\n    const accessToken = response.data.accessToken;\n    const refreshToken = response.data.refreshToken;\n\n    // Store tokens in localStorage for client-side access\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n\n    return {\n      user: response.data.user,\n      accessToken: accessToken || '',\n      refreshToken: refreshToken || '',\n    };\n  },\n\n  // Login to specific organization\n  async loginToOrganization(credentials: LoginCredentials): Promise<AuthResponse> {\n    const response = await api.post('/auth/login/organization', credentials);\n    \n    const accessToken = response.data.accessToken;\n    const refreshToken = response.data.refreshToken;\n\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n\n    return {\n      user: response.data.user,\n      accessToken: accessToken || '',\n      refreshToken: refreshToken || '',\n    };\n  },\n\n  // Login by domain\n  async loginByDomain(credentials: LoginCredentials): Promise<AuthResponse> {\n    const response = await api.post('/auth/login/domain', credentials);\n    \n    const accessToken = response.data.accessToken;\n    const refreshToken = response.data.refreshToken;\n\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n\n    return {\n      user: response.data.user,\n      accessToken: accessToken || '',\n      refreshToken: refreshToken || '',\n    };\n  },\n\n  // Get available organizations\n  async getOrganizations(): Promise<Organization[]> {\n    const response = await api.get('/organizations');\n    return response.data;\n  },\n\n  // Get organization by domain\n  async getOrganizationByDomain(domain: string): Promise<Organization> {\n    const response = await api.get(`/organizations/domain/${domain}`);\n    return response.data;\n  },\n\n  // Register new user\n  async register(userData: RegisterData): Promise<AuthResponse> {\n    const response = await api.post('/auth/register', userData);\n    \n    // Get tokens from response data (backend now returns them)\n    const accessToken = response.data.accessToken;\n    const refreshToken = response.data.refreshToken;\n\n    // Store tokens in localStorage for client-side access\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n\n    return {\n      user: response.data.user,\n      accessToken: accessToken || '',\n      refreshToken: refreshToken || '',\n    };\n  },\n\n  // Logout user\n  async logout(): Promise<void> {\n    try {\n      // Try to call logout endpoint if it exists\n      await api.post('/auth/logout');\n    } catch (error: unknown) {\n      // If logout endpoint doesn't exist (404) or any other error, \n      // just log it but don't throw - logout should always succeed client-side\n      if (error && typeof error === 'object' && 'response' in error && \n          error.response && typeof error.response === 'object' && 'status' in error.response &&\n          error.response.status === 404) {\n        console.log('Logout endpoint not available, proceeding with client-side logout');\n      } else {\n        console.error('Logout error:', error);\n      }\n    } finally {\n      // Always clear tokens from localStorage regardless of backend response\n      localStorage.removeItem('accessToken');\n      localStorage.removeItem('refreshToken');\n    }\n  },\n\n  // Get current user\n  async getCurrentUser(): Promise<User> {\n    const response = await api.get('/auth/me');\n    return response.data;\n  },\n\n  // Refresh token\n  async refreshToken(): Promise<{ accessToken: string }> {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    const response = await api.post('/auth/refresh', { refreshToken });\n    const { accessToken } = response.data;\n    \n    localStorage.setItem('accessToken', accessToken);\n    return { accessToken };\n  },\n\n  // Check if user is authenticated\n  isAuthenticated(): boolean {\n    return !!localStorage.getItem('accessToken');\n  },\n\n  // Get stored access token\n  getAccessToken(): string | null {\n    return localStorage.getItem('accessToken');\n  },\n\n  // Get stored refresh token\n  getRefreshToken(): string | null {\n    return localStorage.getItem('refreshToken');\n  },\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///Users/lord-charles/Code/work/gap_analysis/frontend/contexts/AuthContext.tsx"],"sourcesContent":["'use client';\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { authService, User, LoginCredentials, RegisterData } from '@/lib/auth';\nimport { useRouter } from 'next/navigation';\n\ninterface AuthContextType {\n  user: User | null;\n  isLoading: boolean;\n  isAuthenticated: boolean;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  register: (userData: RegisterData) => Promise<void>;\n  logout: () => Promise<void>;\n  error: string | null;\n  clearError: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const router = useRouter();\n\n  const isAuthenticated = !!user;\n\n  // Check if user is already authenticated on app load\n  useEffect(() => {\n    const checkAuth = async () => {\n      try {\n        if (authService.isAuthenticated()) {\n          const userData = await authService.getCurrentUser();\n          setUser(userData);\n          \n          // Redirect Super Admin to Super Admin dashboard if they're on the regular dashboard\n          if (userData.role === 'SUPER_ADMIN' && window.location.pathname === '/dashboard') {\n            router.push('/dashboard/super-admin');\n          }\n        }\n      } catch (error) {\n        console.error('Auth check failed:', error);\n        // Clear invalid tokens\n        localStorage.removeItem('accessToken');\n        localStorage.removeItem('refreshToken');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    checkAuth();\n  }, [router]);\n\n  const login = async (credentials: LoginCredentials) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const response = await authService.login(credentials);\n      setUser(response.user);\n      \n      // Redirect based on user role\n      if (response.user.role === 'SUPER_ADMIN') {\n        router.push('/dashboard/super-admin');\n      } else {\n        router.push('/dashboard');\n      }\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Login failed. Please try again.';\n      setError(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const register = async (userData: RegisterData) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const response = await authService.register(userData);\n      setUser(response.user);\n      \n      // Redirect based on user role\n      if (response.user.role === 'SUPER_ADMIN') {\n        router.push('/dashboard/super-admin');\n      } else {\n        router.push('/dashboard');\n      }\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Registration failed. Please try again.';\n      setError(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const logout = async () => {\n    try {\n      await authService.logout();\n    } catch (error) {\n      console.error('Logout error:', error);\n    } finally {\n      setUser(null);\n      router.push('/auth/login');\n    }\n  };\n\n  const clearError = () => {\n    setError(null);\n  };\n\n  const value: AuthContextType = {\n    user,\n    isLoading,\n    isAuthenticated,\n    login,\n    register,\n    logout,\n    error,\n    clearError,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAJA;;;;;AAiBA,MAAM,4BAAc,IAAA,kOAAa,EAA8B;AAExD,MAAM,UAAU;IACrB,MAAM,UAAU,IAAA,+NAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAMO,MAAM,eAA4C,CAAC,EAAE,QAAQ,EAAE;IACpE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,6NAAQ,EAAc;IAC9C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,6NAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,6NAAQ,EAAgB;IAClD,MAAM,SAAS,IAAA,2JAAS;IAExB,MAAM,kBAAkB,CAAC,CAAC;IAE1B,qDAAqD;IACrD,IAAA,8NAAS,EAAC;QACR,MAAM,YAAY;YAChB,IAAI;gBACF,IAAI,sIAAW,CAAC,eAAe,IAAI;oBACjC,MAAM,WAAW,MAAM,sIAAW,CAAC,cAAc;oBACjD,QAAQ;oBAER,oFAAoF;oBACpF,IAAI,SAAS,IAAI,KAAK,iBAAiB,OAAO,QAAQ,CAAC,QAAQ,KAAK,cAAc;wBAChF,OAAO,IAAI,CAAC;oBACd;gBACF;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,sBAAsB;gBACpC,uBAAuB;gBACvB,aAAa,UAAU,CAAC;gBACxB,aAAa,UAAU,CAAC;YAC1B,SAAU;gBACR,aAAa;YACf;QACF;QAEA;IACF,GAAG;QAAC;KAAO;IAEX,MAAM,QAAQ,OAAO;QACnB,IAAI;YACF,aAAa;YACb,SAAS;YACT,MAAM,WAAW,MAAM,sIAAW,CAAC,KAAK,CAAC;YACzC,QAAQ,SAAS,IAAI;YAErB,8BAA8B;YAC9B,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK,eAAe;gBACxC,OAAO,IAAI,CAAC;YACd,OAAO;gBACL,OAAO,IAAI,CAAC;YACd;QACF,EAAE,OAAO,OAAY;YACnB,MAAM,eAAe,MAAM,QAAQ,EAAE,MAAM,WAAW;YACtD,SAAS;YACT,MAAM;QACR,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,WAAW,OAAO;QACtB,IAAI;YACF,aAAa;YACb,SAAS;YACT,MAAM,WAAW,MAAM,sIAAW,CAAC,QAAQ,CAAC;YAC5C,QAAQ,SAAS,IAAI;YAErB,8BAA8B;YAC9B,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK,eAAe;gBACxC,OAAO,IAAI,CAAC;YACd,OAAO;gBACL,OAAO,IAAI,CAAC;YACd;QACF,EAAE,OAAO,OAAY;YACnB,MAAM,eAAe,MAAM,QAAQ,EAAE,MAAM,WAAW;YACtD,SAAS;YACT,MAAM;QACR,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,SAAS;QACb,IAAI;YACF,MAAM,sIAAW,CAAC,MAAM;QAC1B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iBAAiB;QACjC,SAAU;YACR,QAAQ;YACR,OAAO,IAAI,CAAC;QACd;IACF;IAEA,MAAM,aAAa;QACjB,SAAS;IACX;IAEA,MAAM,QAAyB;QAC7B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;IAEA,qBAAO,0PAAC,YAAY,QAAQ;QAAC,OAAO;kBAAQ;;;;;;AAC9C","debugId":null}}]
}